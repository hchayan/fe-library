## 🚀 자동차 경주 게임 Q&A

### 앱의 초기화를 위해 새로고침을 사용해야 할까요?

```
재시작 버튼 누를 때, 새로고침 직접하기 또는 동일한 효과를 내는 코드 작성하기 중에 어떤 것이 더 좋은 방법일까요?

새로고침을 직접 하는 것의 장점은 코드가 간결하지만 기존 렌더링된 요소를 다시 불러와야하기 때문에 효율적이지 않습니다.
반면 새로고침과 동일한 효과를 내는 코드를 작성하는 것은 기존 요소를 재활용하기 때문에 효율적입니다.
단, 변경됐던 DOM과 모델을 직접 초기상태로 만들어줘야하기 때문에 코드가 길어지고 이벤트도 삭제하거나 다시 추가해줘야하는 단점이 있습니다.
```

- 사용자 입장에서 새로고침이되면 화면 깜박임을 느끼게 되기 때문에, 사용자가 받아들이는 입장에서는 후자의 방식이 더 좋을 것이라고 생각합니다.
- 새로고침을 직접하게 되면 깜박임 문제도 있고 렌더 되는데 시간도 더 걸려서 후자가 더 좋다고 생각하는 편입니다. 이번 자동차 미션의 경우, 후자의 방식으로도 코드가 별로 길어지지 않았습니다.

<br />

### 랜덤함수 테스트로 검증할 필요가 있을까요?

```
자동차 경주에서 60%의 확률로 전진하는 것이 요구사항인데 다들 이 경우 테스트 진행하셨나요?
테스트는 횟수를 100000 주고, 자동차를 한 개로 설정해서 화살표가 59000 ~ 61000 사이인지 확인하는 식으로 하려고 합니다.
```

- 해당 요구사항을 TDD로 여럿 나누어서 함수를 테스트하는걸로 진행했습니다. 그러면 전진할 때 랜덤값이 영향을 미치는 범위가 랜덤값을 생성하는 함수로 줄어든다고 생각했습니다.
- 랜덤 함수에 대해서는 정확한 테스트를 진행할 수 없을 것이라는 결론이 나왔습니다. 그래서 기존의 레거시 혹은 mdn에서 제공하는 코드를 사용하기로 했습니다. 테스트가 많아질수록 안정성이 보장되기는 하겠지만 그것은 결국 정확한 아웃풋을 도출할 수 있는 테스트에 대한 한정이지 않을까 생각합니다.
- 지금 같은 경우에는 간단한 1자리수의 랜덤을 만들어내는 함수이고, API가 정확하게 문서에 검증된 정보가 있는걸 확인할 수 있기 때문에 꼭 우리가 그 부분을 테스트할 필요는 없습니다.

<br />

### prgressive 재생은 어떻게 구현해야 할까요?

```
자동차 경주 게임의 턴이 진행 될 때마다 1초의 텀(progressive 재생)을 두고 진행한다.
위 요구사항 구현중인데요!
아래 2개 중 어느것이 요구사항에 적절할까요?
1번. 레이싱 시작 -> 1초 대기
2번. 1초 대기 -> 레이싱 시작
```

- 첫번째 게임도 턴으로 생각해서 2번이라고 생각합니다.

```
1초 동안 spinner를 보여주고 화살표를 한번에 출력하라는 건가요?
아니면 시도 횟수가 5일 경우, spinner - 화살표가 총 5번 반복하는 건가요?
```

- 전자로 생각하고 진행했습니다. 본인이 생각하기에 적합한 방식으로 시도해보면 될 것 같아요.
- 후자로 생각하고 진행했습니다. [(구현방법)](https://user-images.githubusercontent.com/60066472/108361067-5b911500-7235-11eb-8b30-2264b1efba0c.png)

<br />

### 정규표현식으로 입력 문자를 제한하려면?

```
이름 입력 창에 이모지 못 입력하게 하는 건 어떻게 구현해야 할까요?
```

- 정규표현식 `/[^가-힣a-zA-Z0-9]/`으로 영문 알파벳, 한글 글자, 숫자가 아닌 경우에는 전부 에러 처리할 수 있습니다.
  - `^` 는 범위 내의 글자와 대응되지 않는 모든 입력을 말합니다.

<br />

### 앱 구조는 어떻게 구상하면 좋을까요?

<p align="center"><img src="https://user-images.githubusercontent.com/60066472/108373306-196ed000-7243-11eb-8f44-be4aa44c2377.png" width="300"></p>

```
과제를 마치고 페어와 회고를 하면서 앱 구조 에 대해서 다시 얘기했었습니다.

1번. 저희는 게임 진행과 게임결과를 하나의 덩어리로 보아야 하는지
2번. 입력부를 두 개의 덩어리로 나눠 보아야 하는지
이렇게 얘기를 나눠봤었어요. 다른 분들은 어떻게 생각하시나요?
```

- 저희는 자동차 이름과 시도횟수 입력을 다른 덩어리로 나눠서 관리했습니다. 올려주신 구조를 보니 자동차 이름 입력과 시도횟수 입력 모두 Input에 입력된 값을 click 이벤트로 처리하는 비슷한 구조니 이벤트 위임 등을 이용해 하나의 덩어리로 관리했어도 좋았겠다는 생각이 듭니다.
- 1번의 경우 분리해서 보았습니다. 확인 버튼이 한 번에 있는 것이 아니라, 각각 분리되어있기 때문에 한 인풋에서 에러가 나고 다른 인풋에서 정상 입력이 돌아오면 그에 대한 작업이 처리된 후 초기화 로직을 돌려야 해서 분리해서 차 이름이 통과한 경우 시도 횟수 부분을 보여지게 했습니다. 2번의 경우에는 서로 다른 화면을 보여주고 있는 거라서, 분리해서 두는 것이 맞다고 생각해서 분리해서 두었습니다. 유저 인풋 내에서 작게 분리했어도 좋겠다는 생각이 듭니다.

<br />

### 원시자료형은 어떻게 프로퍼티값을 가져오고 메서드를 호출할 수 있을까요?

```
아래 스택오버플로우 답변을 찾았는데 타입에 해당하는 객체로 바꿔주는 건가요?
```

https://stackoverflow.com/questions/53149349/how-does-primitive-types-in-javascript-have-methods-and-properties

- 원시자료형 의 coercion이라는 프로퍼티가 암묵적으로 객체로 변환해준다고 이해했어요.
- sloppy mode에서는 래퍼로 감싼다음에 메서드를 호출하고, strict mode 에서는 래퍼객체로 안감싸고 바로 메서드만 빌려워서 처리하는것 같아요.

```js
Number.prototype.testSloppyMode = function () {
  console.log(typeof this);
  console.log(this instanceof Number);
};
Number.prototype.testStrictMode = function () {
  'use strict';
  console.log(typeof this);
  console.log(this instanceof Number);
};
(3).testSloppyMode(); // object true
(3).testStrictMode(); // number false
```
